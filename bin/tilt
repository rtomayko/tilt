#!/usr/bin/env ruby
require 'ostruct'
require 'optparse'
require 'tilt'

usage = <<USAGE
Usage: tilt <options> <files...>

Process templates <file> and write output to stdout. With no <files> or
when <file> is '-', read template from stdin and use the --type option
to determine the template's type.

Output can be written to files (rather than printing to stdout) using the
--files option. In that case the output file for each file is the same as
the input file, with the template extension removed, and the names of the
output files are printed to stdout.  With no <files> or when a <file> is
'-', read files from stdin.

Adjust the output file locations with --input-dir and --output-dir, which
describe the base dir for making relative paths, and the output directory.

Options
  -l, --list             List template engines + file patterns and exit
  -t, --type=<pattern>   Use this template engine; required if no <file>
  -y, --layout=<file>    Use <file> as a layout template

  -f, --files            Output to files rather than stdout
  -i, --input-dir=<dir>  Use <dir> to determine relative paths for --files
  -d, --output-dir=<dir> Use <dir> as the output dir for --files

  -a, --attrs=<file>     Load file as YAML and use for variables
  -D<name>=<value>       Define variable <name> as <value>
  -o, --vars=<ruby>      Evaluate <ruby> to Hash and use for variables

  -h, --help             Show this help message

Convert markdown to HTML:
  $ tilt foo.markdown > foo.html

Process ERB template:
  $ echo "Answer: <%= 2 + 2 %>" | tilt -t erb
  Answer: 4

Process to output file:
  $ echo "Answer: <%= 2 + 2 %>" > foo.txt.erb
  $ tilt --files foo.txt.erb
  foo.txt
  $ cat foo.txt
  Answer: 4

Define variables:
  $ echo "Answer: <%= 2 + n %>" | tilt -t erb --vars="{:n=>40}"
  Answer: 42
  $ echo "Answer: <%= 2 + n.to_i %>" | tilt -t erb -Dn=40
  Answer: 42
USAGE

script_name = File.basename($0)
pattern = nil
layout = nil
locals = {}

ARGV.options do |o|
  o.program_name = script_name

  # list all available template engines
  o.on("-l", "--list") do
    groups = {}
    Tilt.mappings.each do |pattern,engines|
      engines.each do |engine|
        key = engine.name.split('::').last.sub(/Template$/, '')
        (groups[key] ||= []) << pattern
      end
    end
    groups.sort { |(k1,v1),(k2,v2)| k1 <=> k2 }.each do |engine,files|
      printf "%-15s %s\n", engine, files.sort.join(', ')
    end
    exit
  end

  # the template type / pattern
  o.on("-t", "--type=PATTERN", String) do |val|
    abort "unknown template type: #{val}" if Tilt[val].nil?
    pattern = val
  end

  # pass template output into the specified layout template
  o.on("-y", "--layout=FILE", String)  do |file|
    paths = [file, "~/.tilt/#{file}", "/etc/tilt/#{file}"]
    layout = paths.
      map  { |p| File.expand_path(p) }.
      find { |p| File.exist?(p) }
    abort "no such layout: #{file}" if layout.nil?
  end

  # define a local variable
  o.on("-D", "--define=PAIR", String) do |pair|
    key, value = pair.split(/[=:]/, 2)
    locals[key.to_sym] = value
  end

  # define local variables using a Ruby hash
  o.on("--vars=RUBY") do |ruby|
    hash = eval(ruby)
    abort "vars must be a Hash, not #{hash.inspect}" if !hash.is_a?(Hash)
    hash.each { |key, value| locals[key.to_sym] = value }
  end

  o.on_tail("-h", "--help") { puts usage; exit }

  o.parse!
end

file = ARGV.first || '-'
pattern = file if pattern.nil?
abort "template type not given. see: #{$0} --help" if ['-', ''].include?(pattern)

engine = Tilt[pattern]
abort "template engine not found for: #{pattern}" if engine.nil?

template =
  engine.new(file) {
    if file == '-'
      $stdin.read
    else
      File.read(file)
    end
  }
output = template.render(self, locals)

# process layout
output = Tilt.new(layout).render(self, locals) { output } if layout

$stdout.write(output)
