require 'tilt/template'

module Tilt
  # ERB template implementation. See:
  # http://www.ruby-doc.org/stdlib/libdoc/erb/rdoc/classes/ERB.html
  #
  # The template supports encoding detection via first line magic comment:
  # <%# coding: utf-8 %>
  #
  # When present, the string's encoding is adjusted to the specified value.
  class ERBTemplate < Template
    @@default_output_variable = '_erbout'

    def self.default_output_variable
      @@default_output_variable
    end

    def self.default_output_variable=(name)
      @@default_output_variable = name
    end

    def self.engine_initialized?
      defined? ::ERB
    end

    def initialize_engine
      require_template_library 'erb'
    end

    # Create an ERB object and generate the Ruby source code for the template.
    # The resulting source string has the same encoding as the input data
    # *unless* the template includes a magic comment, in which case the source
    # string AND the template data will be marked with the declared encoding.
    #
    # The resulting source string does not include any magic comment line
    # generated by ERB. The string.encoding should be used to determine the
    # source and output encoding.
    def prepare
      @outvar = options[:outvar] || self.class.default_output_variable
      options[:trim] = '<>' if options[:trim].nil? || options[:trim] == true
      @engine = ::ERB.new(data, options[:safe], options[:trim], @outvar)
      @source = assign_encoding(@engine.src)
      @data.force_encoding @source.encoding if @data.respond_to?(:force_encoding)
    end

    # Remove the magic encoding comment line from the generated source string in
    # place and force the string to the detected encoding.
    #
    # Returns the modified source string.
    def assign_encoding(source)
      if source.respond_to?(:force_encoding)
        if encoding = extract_source_encoding(source)
          source.force_encoding encoding
        else
          source.force_encoding data.encoding
        end
      end
      source
    end

    # Override to always return the generated source string.
    def precompiled_template(locals)
      @source
    end

    # Override to store the original state of the output variable before
    # this template is executed.
    def precompiled_preamble(locals)
      <<-RUBY
        begin
          __original_outvar = #{@outvar} if defined?(#{@outvar})
          #{super}
      RUBY
    end

    # Override to reset the output variable to its state before the template
    # was executed.
    def precompiled_postamble(locals)
      <<-RUBY
          #{super}
        ensure
          #{@outvar} = __original_outvar
        end
      RUBY
    end
  end

  # Erubis template implementation. See:
  # http://www.kuwata-lab.com/erubis/
  #
  # ErubisTemplate supports the following additional options, which are not
  # passed down to the Erubis engine:
  #
  #   :engine_class   allows you to specify a custom engine class to use
  #                   instead of the default (which is ::Erubis::Eruby).
  #
  #   :escape_html    when true, ::Erubis::EscapedEruby will be used as
  #                   the engine class instead of the default. All content
  #                   within <%= %> blocks will be automatically html escaped.
  #
  # Unlike ERB, the Erubis template engine does not support encoding detection
  # via magic comment. Encoding declarations are ignored. The :default_encoding
  # option or system default external encoding are used by default.
  class ErubisTemplate < ERBTemplate
    def self.engine_initialized?
      defined? ::Erubis
    end

    def initialize_engine
      require_template_library 'erubis'
    end

    def prepare
      @outvar = options.delete(:outvar) || self.class.default_output_variable
      @options.merge!(:preamble => false, :postamble => false, :bufvar => @outvar)
      engine_class = options.delete(:engine_class)
      engine_class = ::Erubis::EscapedEruby if options.delete(:escape_html)
      @engine = (engine_class || ::Erubis::Eruby).new(data, options)
      @source = assign_encoding(@engine.src)
      @data.force_encoding @source.encoding if @data.respond_to?(:force_encoding)
    end

    def precompiled_preamble(locals)
      [super, "#{@outvar} = _buf = ''"].join("\n")
    end

    def precompiled_postamble(locals)
      [@outvar, super].join("\n")
    end
  end
end

